'use strict'
const fs = require('fs')
const path = require('path')

function getStack(_, stack) {
  return stack
}

/**
 * Utility functions
 */
class Utils {
  /**
   * Read file, parse lines.
   *
   * @static
   * @param {string} [filename=null] - If null, figures out what day today is
   *   and finds the .txt file
   * @returns {Array<string>}
   */
  static readLines(filename) {
    if (!filename) {
      // s/.js$/.txt/ from the calling file.
      filename = this.adjacentFile('.txt')
    }
    return fs.readFileSync(filename, 'utf8')
      .split('\n')
      .filter(s => s.length)
  }

  /**
   * @static
   * @param {string} [filename] - If null, figures out what day today is
   *   and finds the .txt file
   * @param {string|function} [parser] - If a string, the name of the parser
   *   file to require.  If a function, the pre-required parser.  If null,
   *   find the parser with the matching name. If no parser found, split
   *   like `readLines`.
   * @returns {any} - the output of the parser
   */
  static parseFile(filename, parser) {
    if (!filename) {
      filename = this.adjacentFile('.txt')
    }
    const txt = fs.readFileSync(filename, 'utf8')

    if (!parser) {
      parser = this.adjacentFile('.peg.js')
    }

    // @type {function}
    let parserFunc = null
    if (typeof parser === 'function') {
      parserFunc = parser
    } else {
      try {
        parserFunc = require(parser).parse
      } catch {
        console.error(`No parser: "${parser}", falling back on readLines`)
        return txt
          .split('\n')
          .filter(s => s.length)
      }
    }
    return parserFunc(txt)
  }

  static adjacentFile(ext) {
    // idiomatic tcl
    // @ts-ignore: TS2339, tsc can't see the hidden call of `getStack`
    const p = path.parse(this.callsites()[2].getFileName())
    return path.join(p.dir, p.name + ext)
  }

  static callsites() {
    const old = Error.prepareStackTrace
    Error.prepareStackTrace = getStack
    const stack = new Error().stack.slice(1) // i am never interesting
    Error.prepareStackTrace = old
    return stack
  }

  /**
   * Modulo, minus the JS bug with negative numbers.
   * `-5 % 4` should be `3`, not `-1`.
   *
   * @static
   * @param {number|BigInt} x
   * @param {number|BigInt} y
   * @returns {number|BigInt} x mod y
   */
  static mod(x, y) {
    // == works with either 0 or 0n.
    if (y == 0) {
      throw new Error(`Division by zero`)
    }
    // @ts-ignore: TS2365.  tsc can't see that x and y are always the same type
    return ((x % y) + y) % y
  }

  /**
   * Integer result of x / y, plus the modulo (unsigned) remainder.
   *
   * @static
   * @param {number|BigInt} x
   * @param {number|BigInt} y
   * @returns {[number|BigInt, number|BigInt]} - the quotient and remainder
   */
  static divmod(x, y) {
    // @ts-ignore: TS2362.  x and y are the same time.  We're fine.
    let q = x / y
    const r = this.mod(x, y)
    if (typeof x === 'bigint') {
      // not only does Math.floor not work for BigInt, it's not needed because
      // `/` does the right thing in the first place.

      // except for numbers of opposite sign
      if ((q < 0n) && (r > 0)) {
        // There was a remainder.  JS rounded toward zero, but python
        // rounds down.
        q--
      }
      return [ q, r ]
    }
    return [ Math.floor(q), r ]
  }

  /**
   * @callback itSomeCallback
   * @param {any} item - The item of the iterator to check
   * @param {number} index - The index of the item in the iterator
   * @returns {boolean} - Does this item match?
   */
  /**
   * Tests whether at least one element generated by the iterator passes the
   * test implemented by the provided function
   *
   * @static
   * @param {IterableIterator<any>} it - the iterator.  It may not be fully consumed.
   * @param {itSomeCallback} f
   * @param {any} [thisArg] - what is `this` in the function `f`?
   * @returns
   */
  static itSome(it, f, thisArg) {
    let count = 0
    for (const i of it) {
      if (!!f.call(thisArg, i, count++)) {
        return true
      }
    }
    return false
  }

  /**
   * Is the given thing iterable?
   *
   * @static
   * @param {any} g - the thing to check
   * @returns {boolean} - true if `g` looks like an iterable
   */
  static isIterable(g) {
    return g &&
      (typeof g === 'object') &&
      (g[Symbol.iterator])
  }


  // BELOW lifted from https://github.com/aureooms/js-itertools,
  // removed need for weird runtime
  // ----------

  /**
   * Like Python's range(), generate a series of numbers.
   *
   * @static
   * @param {number} start - the starting point
   * @param {number} [stop] - the ending point, which isn't reached
   * @param {number} [step=1] - how much to add each time, may be negative
   * @yields {number} - each number in the range
   */
  static *range(start, stop, step=1) {
    if (stop == null) {
      [start, stop] = [0, start]
    }
    if (step < 0) {
      while (start > stop) {
        yield start
        start += step
      }
    } else {
      while (start < stop) {
        yield start
        start += step
      }
    }
  }

  /**
   * Pick some properties or array values out of `source`.
   *
   * @static
   * @param {Object|Array<any>|Iterable<any>} source - thing to select from
   * @param {IterableIterator<number|string>|Iterable<number|string>} it - the indexes or property names
   * @yields {any} - the selected property
   */
  static *pick(source, it) {
    if (this.isIterable(source)) {
      // TODO: this is slower than it should be, but `it` might be out
      // of order, and so might `source`.
      source = [...source]
    }
    for (const i of it) {
      yield source[i]
    }
  }

  /**
   * Combinations of a series, r at a time
   *
   * @static
   * @param {IterableIterator<any>} iterable - the series to iterate.
   * @param {number} r - How many of the series to use in each combination?
   * @yields {Array<any>} - each combination
   */
  static *combinations(iterable, r) {
    const pool = Array.isArray(iterable) ? iterable : [...iterable]
    const length = pool.length

    if (r > length) {
      return
    }

    const indices = [...this.range(r)]
    yield [...this.pick(pool, indices)]

    while (true) {
      let i = r - 1
      while (true) {
        if (i < 0) {
          return
        }
    
        if (indices[i] !== i + length - r) {
          let pivot = ++indices[i]
          for (++i; i < r; ++i) {
            indices[i] = ++pivot
          }
          break
        }
        i--
      }
    
      yield [...this.pick(pool, indices)]
    }
  }

  static *trunc(iterable, n) {
    if (n < 0) {
      yield* this.take(iterable, -n)
      return
    }

    if (n === 0) {
      yield* iterable
      return
    }

    // buffer up n entries, then serve old ones as we go
    const buffer = new Array(n)
    let cur = 0
    let left = n
    for (const value of iterable) {
      if (left > 0) {
        left--
      } else {
        yield buffer[cur]
      }
      buffer[cur] = value
      cur = (cur + 1) % n
    }
  }

  static *take(iterable, n) {
    if (n == 0) {
      return
    }

    if (n < 0) {
      yield* this.trunc(iterable, -n)
      return
    }

    for (const val of iterable) {
      yield val
      if (--n <= 0) {
        return
      }
    }
  }

  static *permutations(iterable, r) {
    const pool = [...iterable]
    const length = pool.length

    if (r > length) {
      return
    }

    const indices = [...this.range(length)]
    const cycles = [...this.range(length, length - r, -1)]

    yield [...this.pick(pool, this.take(indices, r))]

    if (r === 0 || length === 0) {
      return
    }

    while (true) {
      let i = r

      while (i--) {
        --cycles[i]

        if (cycles[i] === 0) {
          // Could be costly
          indices.push(indices.splice(i, 1)[0])

          cycles[i] = length - i
        } else {
          const j = cycles[i];
          [indices[i], indices[length - j]] = [indices[length - j], indices[i]]
          yield [...this.pick(pool, this.take(indices, r))]
          break
        }
      }

      if (i === -1) {
        return
      }
    }
  }

  static *powerset(iterable) {
    const pool = [...iterable]
    for (const len of this.range(pool.length + 1)) {
      yield* this.combinations(pool, len)
    }
  }
}

module.exports = Utils

