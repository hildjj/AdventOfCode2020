'use strict'
const fs = require('fs')
const path = require('path')

function getStack(_, stack) {
  return stack
}

/**
 * Utility functions
 */
class Utils {
  /**
   * Read file, parse lines.
   *
   * @static
   * @param {string} [filename=null] - If null, figures out what day today is
   *   and finds the .txt file
   * @returns {Array<string>}
   */
  static readLines(filename) {
    if (!filename) {
      // s/.js$/.txt/ from the calling file.
      filename = this.adjacentFile('.txt')
    }
    return fs.readFileSync(filename, 'utf8')
      .split('\n')
      .filter(s => s.length)
  }

  /**
   * @static
   * @param {string} [filename] - If null, figures out what day today is
   *   and finds the .txt file
   * @param {string|function} [parser] - If a string, the name of the parser
   *   file to require.  If a function, the pre-required parser.  If null,
   *   find the parser with the matching name. If no parser found, split
   *   like `readLines`.
   * @returns {any} - the output of the parser
   */
  static parseFile(filename, parser) {
    if (!filename) {
      filename = this.adjacentFile('.txt')
    }
    const txt = fs.readFileSync(filename, 'utf8')

    if (!parser) {
      parser = this.adjacentFile('.peg.js')
    }
    if (typeof parser !== 'function') {
      try {
        parser = require(parser).parse
      } catch {
        console.error(`No parser: "${parser}", falling back on readLines`)
        return txt
          .split('\n')
          .filter(s => s.length)
      }
    }
    return parser(txt)
  }

  static adjacentFile(ext) {
    // idiomatic tcl
    // @ts-ignore: TS2339, tsc can't see the hidden call of `getStack`
    const p = path.parse(this.callsites()[2].getFileName())
    return path.join(p.dir, p.name + ext)
  }

  static callsites() {
    const old = Error.prepareStackTrace
    Error.prepareStackTrace = getStack
    const stack = new Error().stack.slice(1) // i am never interesting
    Error.prepareStackTrace = old
    return stack
  }

  /**
   * @callback itSomeCallback
   * @param {any} item - The item of the iterator to check
   * @param {number} index - The index of the item in the iterator
   * @returns {boolean} - Does this item match?
   */
  /**
   * Tests whether at least one element generated by the iterator passes the
   * test implemented by the provided function
   *
   * @static
   * @param {IterableIterator<any>} it - the iterator.  It may not be fully consumed.
   * @param {itSomeCallback} f
   * @param {any} [thisArg] - what is `this` in the function `f`?
   * @returns
   */
  static itSome(it, f, thisArg) {
    let count = 0
    for (const i of it) {
      if (!!f.call(thisArg, i, count++)) {
        return true
      }
    }
    return false
  }

  /**
   * Is the given thing iterable?
   *
   * @static
   * @param {any} g - the thing to check
   * @returns {boolean} - true if `g` looks like an iterable
   */
  static isIterable(g) {
    return g &&
      (typeof g === 'object') &&
      (g[Symbol.iterator])
  }


  // BELOW lifted from https://github.com/aureooms/js-itertools,
  // removed need for weird runtime
  // ----------

  /**
   * Like Python's range(), generate a series of numbers.
   *
   * @static
   * @param {number} start - the starting point
   * @param {number} [stop] - the ending point, which isn't reached
   * @param {number} [step=1] - how much to add each time, may be negative
   * @yields {number} - each number in the range
   */
  static *range(start, stop, step=1) {
    if (stop == null) {
      [start, stop] = [0, start]
    }
    if (step < 0) {
      while (start > stop) {
        yield start
        start += step
      }
    } else {
      while (start < stop) {
        yield start
        start += step
      }
    }
  }

  /**
   * Pick some properties or array values out of `source`.
   *
   * @static
   * @param {Object|Array<any>|Iterable<any>} source - thing to select from
   * @param {IterableIterator<number|string>|Iterable<number|string>} it - the indexes or property names
   * @yields {any} - the selected property
   */
  static *pick(source, it) {
    if (this.isIterable(source)) {
      // TODO: this is slower than it should be, but `it` might be out
      // of order, and so might `source`.
      source = [...source]
    }
    for (const i of it) {
      yield source[i]
    }
  }

  /**
   * Combinations of a series, r at a time
   *
   * @static
   * @param {IterableIterator<any>} iterable - the series to iterate.
   * @param {number} r - How many of the series to use in each combination?
   * @yields {Array<any>} - each combination
   */
  static *combinations(iterable, r) {
    const pool = Array.isArray(iterable) ? iterable : [...iterable]
    const length = pool.length

    if (r > length) {
      return
    }

    const indices = [...this.range(r)]
    yield [...this.pick(pool, indices)]

    while (true) {
      let i = r - 1
      while (true) {
        if (i < 0) {
          return
        }
    
        if (indices[i] !== i + length - r) {
          let pivot = ++indices[i]
          for (++i; i < r; ++i) {
            indices[i] = ++pivot
          }
          break
        }
        i--
      }
    
      yield [...this.pick(pool, indices)]
    }
  }
}

module.exports = Utils

